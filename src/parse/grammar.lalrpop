use std::str::FromStr;

use ast;
use parse::literal;

grammar;

Comma<T>: Vec<T> = {
  <h: T?> <t: (COMMA <T>)*> => {
    match h {
    | None    => t,
    | Some(e) => {
      let mut v = vec![e];
      v.extend(t);
      v
    }}
  }
}

Semicolon<T> : Vec<T> = {
  <h: T?> <t: (SEMICOLON <T>)*> => {
    match h {
    | None    => t,
    | Some(e) => {
      let mut v = vec![e];
      v.extend(t);
      v
    }}
  }
}

pub Program: Vec<ast::Dec> = {
  TypeDecRec,
  VarDecRec,
  FunDecRec,
}

TypeDecRec: Vec<ast::Dec> = {

  <l: @L> <decs: TypeDec+> <r: @R> <rest: VarDecRec> => {
    let mut rest = rest;
    rest.insert(0, ast::Dec::Type(decs, ast::to_span(l, r)));
    rest
  },

  <l: @L> <decs: TypeDec+> <r: @R> <rest: FunDecRec> => {
    let mut rest = rest;
    rest.insert(0, ast::Dec::Type(decs, ast::to_span(l, r)));
    rest
  },

  <l: @L> <decs: TypeDec+> <r: @R> => {
    vec![ast::Dec::Type(decs, ast::to_span(l, r))]  
  },

}

TypeDec: ast::TypeDec = {

  // type type-id = ty
  <l: @L> TYPE <name: ID> "=" <ty: Type> <r: @R> => { ast::TypeDec{ name, ty, span: ast::to_span(l, r) } },

}

Type: ast::Type = {

  // ty -> type-id
  <l: @L> <name: ID> <r: @R> => ast::Type::Name( name, ast::to_span(l, r)),

  // ty -> { tyfields }
  <l: @L> LBRACK <fields: Comma<FieldDec>> RBRACK <r: @R> => ast::Type::Rec(fields, ast::to_span(l, r)),

  // ty -> array of type-id
  <l: @L> ARRAY OF <name: ID> <r: @R> => ast::Type::Arr(name, ast::to_span(l, r)),

}

FieldDec: ast::FieldDec = {

  // tyfields -> id : type-id
  <l: @L> <name: ID> COLON <ty: ID> <r: @R> => {
    ast::FieldDec { name, escape: false, ty, span: ast::to_span(l, r) }
  },

}

VarDecRec: Vec<ast::Dec> = {

  <dec: VarDec> <rest: Program> => {
    let mut rest = rest;
    rest.insert(0, dec);
    rest
  },

  <dec: VarDec> => { vec![dec] },

}

VarDec: ast::Dec = {

  // var id := exp
  <l: @L> VAR <name: ID> ASSIGN <init: Exp> <r: @R> => {
    ast::Dec::Var { name, escape: false, ty: None, init, span: ast::to_span(l, r) }
  },

  // var id: type-id := exp
  <l: @L> VAR <name: ID> COLON <ty: ID> ASSIGN <init: Exp> <r: @R> => {
    ast::Dec::Var { name, escape: false, ty: Some(ty), init, span: ast::to_span(l, r) }
  },

}

Var: ast::Var = {

  // Simple variable
  <l: @L> <name: ID> <r: @R> => ast::Var::Simple(name, ast::to_span(l, r)),

  // Field lookup
  <l: @L> <name: Var> DOT <field: ID> <r: @R> => ast::Var::Field(Box::new(name), field, ast::to_span(l, r)),

  // Array index
  <l: @L> <name: Var> LBRACE <idx: Exp> RBRACE <r: @R> => ast::Var::Index(Box::new(name), Box::new(idx), ast::to_span(l, r)),

}

FunDecRec: Vec<ast::Dec> = {

  <l: @L> <decs: FunDec+> <r: @R> <rest: TypeDecRec> => {
    let mut rest = rest;
    rest.insert(0, ast::Dec::Fun(decs, ast::to_span(l, r)));
    rest
  },

  <l: @L> <decs: FunDec+> <r: @R> <rest: VarDecRec> => {
    let mut rest = rest;
    rest.insert(0, ast::Dec::Fun(decs, ast::to_span(l, r)));
    rest
  },

  <l: @L> <decs: FunDec+> <r: @R> => {
    vec![ast::Dec::Fun(decs, ast::to_span(l, r))]
  }

}

FunDec: ast::FunDec = {

  // fundec -> function id ( tyfields ) = exp
  <l: @L> FUNCTION <name: ID> LPAREN <args: FieldDec*> RPAREN EQ <body: Stm> <r: @R> => {
    ast::FunDec { name, args, rets: None, body, span: ast::to_span(l, r) }
  },

  // fundec -> function id ( tyfields ) : type-id = exp
  <l: @L> FUNCTION <name: ID> LPAREN <args: FieldDec*> RPAREN COLON <rets: ID> EQ <body: Stm> <r: @R> => {
    ast::FunDec { name, args, rets: Some(rets), body, span: ast::to_span(l, r) }
  },

}

// Refer to http://www.parsifalsoft.com/ifelse.html
Stm: ast::Exp = {

  OpenStm,

  ClosedStm,

}

OpenStm: ast::Exp = {

  <l: @L> IF <guard: Exp> THEN <then: Stm> <r: @R> => {
    ast::Exp::If{ guard: Box::new(guard), then: Box::new(then), or: None, span: ast::to_span(l, r) }
  },

  <l: @L> IF <guard: Exp> THEN <then: ClosedStm> ELSE <or: OpenStm> <r: @R> => {
    ast::Exp::If{ guard: Box::new(guard), then: Box::new(then), or: Some(Box::new(or)), span: ast::to_span(l, r) }
  },

  // While statement
  <l: @L> WHILE <guard: Exp> DO <body: OpenStm> <r: @R> => {
    ast::Exp::While{ guard: Box::new(guard), body: Box::new(body), span: ast::to_span(l, r) }
  },

  // For statement
  <l: @L> FOR <name: ID> ASSIGN <lo: Exp> TO <hi: Exp> DO <body: OpenStm> <r: @R> => {
    ast::Exp::For{ name, escape: false, lo: Box::new(lo), hi: Box::new(hi), body: Box::new(body), span: ast::to_span(l, r) }
  },

}

ClosedStm: ast::Exp = {

  // While statement
  <l: @L> WHILE <guard: Exp> DO <body: ClosedStm> <r: @R> => {
    ast::Exp::While{ guard: Box::new(guard), body: Box::new(body), span: ast::to_span(l, r) }
  },

  // For statement
  <l: @L> FOR <name: ID> ASSIGN <lo: Exp> TO <hi: Exp> DO <body: ClosedStm> <r: @R> => {
    ast::Exp::For{ name, escape: false, lo: Box::new(lo), hi: Box::new(hi), body: Box::new(body), span: ast::to_span(l, r) }
  },

  // Assignment
  <l: @L> <name: Var> ASSIGN <exp: Exp> <r: @R> => {
    ast::Exp::Ass{ name, exp: Box::new(exp), span: ast::to_span(l, r) }
  },

  Exp,

}

Exp: ast::Exp = {

  // If with else
  <l: @L> IF <guard: Exp> THEN <body: ClosedStm> ELSE <or: ClosedStm> <r: @R> => {
    ast::Exp::If{ guard: Box::new(guard), then: Box::new(body), or: Some(Box::new(or)), span: ast::to_span(l, r) }
  },

  // Let statement
  <l: @L> LET <decs: Program> IN <lb: @L> <body: Semicolon<Stm>> <rb: @R> END <r: @R> => {
    ast::Exp::Let{ decs, body: Box::new(ast::Exp::Seq(body, ast::to_span(lb, rb))), span: ast::to_span(l, r) }
  },

  Or,

}

Or: ast::Exp = {

  // Logical OR
  <l: @L> <lhs: Or> OR <rhs: And> <r: @R> => {
    ast::Exp::Bin{ lhs: Box::new(lhs), op: ast::Binop::LOr, rhs: Box::new(rhs), span: ast::to_span(l, r) }
  },

  And,

}

And: ast::Exp = {

  // Logical AND
  <l: @L> <lhs: And> AND <rhs: Compare> <r: @R> => {
    ast::Exp::Bin{ lhs: Box::new(lhs), op: ast::Binop::LAnd, rhs: Box::new(rhs), span: ast::to_span(l, r) }
  },

  Compare,

}

Compare: ast::Exp = {

  // Comparison operators
  <l: @L> <lhs: Term> <op: CompareOp> <rhs: Term> <r: @R> => {
    ast::Exp::Bin{ lhs: Box::new(lhs), op, rhs: Box::new(rhs), span: ast::to_span(l, r) }
  },

  Term,

}

CompareOp: ast::Binop = {
  GE  => ast::Binop::Ge,
  GT  => ast::Binop::Gt,
  LE  => ast::Binop::Le,
  LT  => ast::Binop::Lt,
  NEQ => ast::Binop::Neq,
  EQ  => ast::Binop::Eq,
}

Term: ast::Exp = {

  // Addition and subtraction
  <l: @L> <lhs: Term> <op: TermOp> <rhs: Factor> <r: @R> => {
    ast::Exp::Bin{ lhs: Box::new(lhs), op, rhs: Box::new(rhs), span: ast::to_span(l, r) }
  },

  Factor,

}

TermOp: ast::Binop = {
  ADD => ast::Binop::Add,
  SUB => ast::Binop::Sub,
}

Factor: ast::Exp = {

  // Multiplication and division
  <l: @L> <lhs: Factor> <op: FactorOp> <rhs: Unary> <r: @R> => {
    ast::Exp::Bin{ lhs: Box::new(lhs), op, rhs: Box::new(rhs), span: ast::to_span(l, r) }
  },

  Unary,

}

FactorOp: ast::Binop = {
  DIV => ast::Binop::Div,
  MUL => ast::Binop::Mul,
}

Unary: ast::Exp = {

  // Unary negation
  <l: @L> SUB <exp: Unary> <r: @R> => ast::Exp::Neg(Box::new(exp), ast::to_span(l, r)),

  Atom,

}

Atom: ast::Exp = {

  // Variable
  <l: @L> <v: Var> <r: @R> => ast::Exp::Var(v, ast::to_span(l, r)),

  // Literal int
  <l: @L> <val: INT> <r: @R> => ast::Exp::Int(val, ast::to_span(l, r)),

  // Literal nil
  <l: @L> NIL <r: @R> => ast::Exp::Nil(ast::to_span(l, r)),

  // // Literal array
  // <l: @L> <name: ID> LBRACE <size: Exp> RBRACE OF <init: Exp> <r: @R> => {
  //   ast::Exp::Arr{ name, size: Box::new(size), init: Box::new(init), span: ast::to_span(l, r) }
  // },

  // Literal record
  <l: @L> <name: ID> LBRACK <fields: Comma<Field>> RBRACK <r: @R> => {
    ast::Exp::Rec{ name, fields, span: ast::to_span(l, r) }
  },

  // Function call
  <l: @L> <name: ID> LPAREN <args: Comma<Exp>> RPAREN <r: @R> => {
    ast::Exp::Call{ name, args, span: ast::to_span(l, r) }
  },

  // Sequence
  <l: @L> LPAREN <exps: Semicolon<Stm>> RPAREN <r: @R> => ast::Exp::Seq(exps, ast::to_span(l, r)),

  // Break
  <@L> BREAK <@R> => ast::Exp::Break(ast::to_span(<>)),

}

Field: ast::Field = {
  <l: @L> <name: ID> EQ <exp: Exp> <r: @R> => ast::Field { name, exp: Box::new(exp), span: ast::to_span(l, r) },
}

// Keywords

TYPE     : () = "type";
VAR      : () = "var";
FUNCTION : () = "function";
BREAK    : () = "break";
OF       : () = "of";
END      : () = "end";
IN       : () = "in";
NIL      : () = "nil";
LET      : () = "let";
DO       : () = "do";
TO       : () = "to";
FOR      : () = "for";
WHILE    : () = "while";
ELSE     : () = "else";
THEN     : () = "then";
IF       : () = "if";
ARRAY    : () = "array";

// Operators

ASSIGN    : () = ":=";
OR        : () = "|";
AND       : () = "&";
GE        : () = ">=";
GT        : () = ">";
LE        : () = "<=";
LT        : () = "<";
NEQ       : () = "<>";
EQ        : () = "=";
DIV       : () = "/";
MUL       : () = "*";
SUB       : () = "-";
ADD       : () = "+";
DOT       : () = ".";

// Miscellaneous

LBRACE    : () = "[";
RBRACE    : () = "]";
LBRACK    : () = "{";
RBRACK    : () = "}";
LPAREN    : () = "(";
RPAREN    : () = ")";
SEMICOLON : () = ";";
COLON     : () = ":";
COMMA     : () = ",";

ID: String = <r"[a-zA-Z][a-zA-Z0-9_]*"> => String::from(<>);
INT: i32 = <r"[0-9]+"> => i32::from_str(<>).unwrap();
STR: String = <"[^\"]*"> => literal::escape_str(<>);
