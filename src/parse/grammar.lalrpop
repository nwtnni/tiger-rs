use std::str::FromStr;

use ast;
use parse::literal;

grammar;

Comma<T>: Vec<T> = {
  <h: T?> <t: (COMMA <T>)*> => {
    match h {
    | None    => t,
    | Some(e) => {
      let mut v = vec![e];
      v.extend(t);
      v
    }}
  }
}

Semicolon<T> : Vec<T> = {
  <h: T?> <t: (SEMICOLON <T>)*> => {
    match h {
    | None    => t,
    | Some(e) => {
      let mut v = vec![e];
      v.extend(t);
      v
    }}
  }
}

pub Program: Vec<ast::Dec> = {
  TypeDecRec,
  VarDecRec,
  FunDecRec,
}

TypeDecRec: Vec<ast::Dec> = {

  <l: @L> <decs: TypeDec+> <r: @R> <rest: VarDecRec> => {
    let mut rest = rest;
    rest.insert(0, ast::Dec::Type(decs, ast::to_span(l, r)));
    rest
  },

  <l: @L> <decs: TypeDec+> <r: @R> <rest: FunDecRec> => {
    let mut rest = rest;
    rest.insert(0, ast::Dec::Type(decs, ast::to_span(l, r)));
    rest
  },

}

TypeDec: ast::TypeDec = {

  // type type-id = ty
  <l: @L> TYPE <name: ID> "=" <ty: Type> <r: @R> => { ast::TypeDec{ name, ty, span: ast::to_span(l, r) } },

}

Type: ast::Type = {

  // ty -> type-id
  <l: @L> <name: ID> <r: @R> => ast::Type::Name( name, ast::to_span(l, r)),

  // ty -> { tyfields }
  <l: @L> LBRACK <fields: Comma<FieldDec>> RBRACK <r: @R> => ast::Type::Rec(fields, ast::to_span(l, r)),

  // ty -> array of type-id
  <l: @L> ARRAY OF <name: ID> <r: @R> => ast::Type::Arr(name, ast::to_span(l, r)),

}

FieldDec: ast::FieldDec = {

  // tyfields -> id : type-id
  <l: @L> <name: ID> COLON <ty: ID> <r: @R> => {
    ast::FieldDec { name, escape: false, ty, span: ast::to_span(l, r) }
  },

}

VarDecRec: Vec<ast::Dec> = {

  <dec: VarDec> <rest: TypeDecRec> => {
    let mut rest = rest;
    rest.insert(0, dec);
    rest
  },

  <dec: VarDec> <rest: FunDecRec> => {
    let mut rest = rest;
    rest.insert(0, dec);
    rest
  },

}

VarDec: ast::Dec = {

  // var id := exp
  <l: @L> VAR <name: ID> ASSIGN <init: Exp> <r: @R> => {
    ast::Dec::Var { name, escape: false, ty: None, init, span: ast::to_span(l, r) }
  },

  // var id: type-id := exp
  <l: @L> VAR <name: ID> COLON <ty: ID> ASSIGN <init: Exp> <r: @R> => {
    ast::Dec::Var { name, escape: false, ty: Some(ty), init, span: ast::to_span(l, r) }
  },

}

FunDecRec: Vec<ast::Dec> = {

  <l: @L> <decs: FunDec+> <r: @R> <rest: TypeDecRec> => {
    let mut rest = rest;
    rest.insert(0, ast::Dec::Fun(decs, ast::to_span(l, r)));
    rest
  },

  <l: @L> <decs: FunDec+> <r: @R> <rest: VarDecRec> => {
    let mut rest = rest;
    rest.insert(0, ast::Dec::Fun(decs, ast::to_span(l, r)));
    rest
  },

}

FunDec: ast::FunDec = {

  // fundec -> function id ( tyfields ) = exp
  <l: @L> FUNCTION <name: ID> LPAREN <args: FieldDec*> RPAREN EQ <body: Exp> <r: @R> => {
    ast::FunDec { name, args, rets: None, body, span: ast::to_span(l, r) }
  },

  // fundec -> function id ( tyfields ) : type-id = exp
  <l: @L> FUNCTION <name: ID> LPAREN <args: FieldDec*> RPAREN COLON <rets: ID> EQ <body: Exp> <r: @R> => {
    ast::FunDec { name, args, rets: Some(rets), body, span: ast::to_span(l, r) }
  },

}

Exp: ast::Exp = {
  <l: @L> LPAREN <exps: Semicolon<Stm>> RPAREN <r: @R> => ast::Exp::Seq(exps, ast::to_span(l, r)),
  Stm,
}

Stm: ast::Exp = {

  // If statement without else block
  <l: @L> IF <guard: StmElse> THEN <then: StmElse> <r: @R> => {
    ast::Exp::If{ guard: Box::new(guard), then: Box::new(then), or: None, span: ast::to_span(l, r) }
  },

  // While statement
  <l: @L> WHILE <guard: StmElse> DO <body: StmElse> <r: @R> => {
    ast::Exp::While{ guard: Box::new(guard), body: Box::new(body), span: ast::to_span(l, r) }
  },

  // For statement
  <l: @L> FOR <name: ID> ASSIGN <lo: StmElse> TO <hi: StmElse> DO <body: StmElse> <r: @R> => {
    ast::Exp::For{ name, escape: false, lo: Box::new(lo), hi: Box::new(hi), body: Box::new(body), span: ast::to_span(l, r) }
  },

  // Let statement
  <l: @L> LET <decs: Program> IN <lb: @L> <body: Semicolon<Exp>> <rb: @R> END <r: @R> => {
    ast::Exp::Let{ decs, body: Box::new(ast::Exp::Seq(body, ast::to_span(lb, rb))), span: ast::to_span(l, r) }
  },

  // Assignment
  <l: @L> <name: StmElse> ASSIGN <exp: Exp> <r: @R> => {
    ast::Exp::Ass{ name, exp: Box::new(exp), span: ast::to_span(l, r) }
  },

  StmElse,
}

StmElse: ast::Exp = {

  // If with else
  <l: @L> IF <guard: Exp> THEN <body: Compare> ELSE <or: Exp> <r: @R> => {
    ast::Exp::If{ guard: Box::new(guard), then: Box::new(body), or: Some(Box::new(or)), span: ast::to_span(l, r) }
  },

  Compare,

}

Compare: ast::Exp = {

  Atom,

}

Atom: ast::Exp = {

  // Literal int
  <l: @L> <val: INT> <r: @R> => ast::Exp::Int(val, ast::to_span(l, r)),

  // Literal nil
  <l: @L> NIL <r: @R> => ast::Exp::Nil(ast::to_span(l, r)),

  // Literal array or
  <l: @L> <name: ID> LBRACE <size: Exp> RBRACE OF <init: Exp> <r: @R> => {
    ast::Exp::Arr{ name, size: Box::new(size), init: Box::new(init), span: ast::to_span(l, r) }
  },

  // Literal record
  <l: @L> <name: ID> LBRACK <fields: Comma<Field>> RBRACK <r: @R> => {
    ast::Exp::Rec{ name, fields, span: ast::to_span(l, r) }
  },

  // Function call
  <l: @L> <name: ID> LPAREN <args: Exp*> RPAREN <r: @R> => {
    ast::Exp::Call{ name, args, span: ast::to_span(l, r) }
  },

  // Break
  <@L> BREAK <@R> => ast::Exp::Break(ast::to_span(<>)),

  // Unary negation
  <l: @L> SUB <exp: Exp> <r: @R> => ast::Exp::Neg(Box::new(exp), ast::to_span(l, r)),

  // lvalue -> id
  <l: @L> <name: ID> <r: @R> => ast::Var::Simple(name, ast::to_span(l, r)),

  // lvalue -> lvalue . id
  <l: @L> <name: Exp> DOT <field: ID> <r: @R> => ast::Var::Field(Box::new(name), field, ast::to_span(l, r)),

  // lvalue -> lvalue [ exp ]
  <l: @L> <name: Exp> LBRACE <idx: Exp> RBRACE => ast::Var::Index(Box::new(name), idx, ast::to_span(l, r)),

  // Parenthesized expression
  LPAREN <Exp> RPAREN,
}

Field: ast::Field = {
  <l: @L> <name: ID> EQ <exp: Exp> <r: @R> => ast::Field { name, exp: Box::new(exp), span: ast::to_span(l, r) },
}

// Keywords

TYPE     : () = "type";
VAR      : () = "var";
FUNCTION : () = "function";
BREAK    : () = "break";
OF       : () = "of";
END      : () = "end";
IN       : () = "in";
NIL      : () = "nil";
LET      : () = "let";
DO       : () = "do";
TO       : () = "to";
FOR      : () = "for";
WHILE    : () = "while";
ELSE     : () = "else";
THEN     : () = "then";
IF       : () = "if";
ARRAY    : () = "array";

// Operators

ASSIGN    : () = ":=";
OR        : () = "|";
AND       : () = "&";
GE        : () = ">=";
GT        : () = ">";
LE        : () = "<=";
LT        : () = "<";
NEQ       : () = "<>";
EQ        : () = "=";
DIV       : () = "/";
MUL       : () = "*";
SUB       : () = "-";
ADD       : () = "+";
DOT       : () = ".";

// Miscellaneous

LBRACE    : () = "[";
RBRACE    : () = "]";
LBRACK    : () = "{";
RBRACK    : () = "}";
LPAREN    : () = "(";
RPAREN    : () = ")";
SEMICOLON : () = ";";
COLON     : () = ":";
COMMA     : () = ",";

ID: String = <r"[a-zA-Z][a-zA-Z0-9_]*"> => String::from(<>);
INT: i32 = <r"[0-9]+"> => i32::from_str(<>).unwrap();
STR: String = <"[^\"]*"> => literal::escape_str(<>);
